import hashlib

from ecdsa import SigningKey, numbertheory, SECP256k1
from ecdsa.util import sigdecode_string, string_to_number

inv = numbertheory.inverse_mod

def decode_sig(sig):
    r, s = sigdecode_string(sig, SECP256k1.generator.order())
    return r, s


user = b"lol"
r1, s1 = decode_sig(
    bytes.fromhex("cac6d0d70a88b0c95fd9c6c03261faf01aa51231864017b9b32fea67cf3ffc19316d2cea71faadad8046e37482bafa965ec92f446668acae232763ec7b948c90")
)
z1 = string_to_number(hashlib.sha1(user).digest())


user2 = b"lol2"
r2, s2 = decode_sig(
    bytes.fromhex("cac6d0d70a88b0c95fd9c6c03261faf01aa51231864017b9b32fea67cf3ffc196ecde7dc924e2d1c18275db0f5c84c41bc298ac191475c55d4d29d3632d7a7f8")
)
z2 = string_to_number(hashlib.sha1(user2).digest())

assert r1 == r2, "Different nonce was used"

k = (z1 - z2) * inv(s1 - s2, SECP256k1.generator.order())
print(k % SECP256k1.generator.order())
secret_key = ((s1 * k - z1) * inv(r1, SECP256k1.generator.order())) % SECP256k1.generator.order()

print(secret_key)

sk = SigningKey.from_secret_exponent(secret_key, SECP256k1)
print("Token: admin," + sk.sign(b"admin").hex())